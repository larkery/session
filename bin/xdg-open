#!/usr/bin/env zsh
if [ "$1" = "-bg" ]; then
    shift
    xdg-open "$@" &
    disown
    exit
fi

RULES_FILE="$HOME/.config/open-rules"

if [ "$1" = "-rules" ]; then
    shift
    RULES_FILE="$1"
    shift
fi

err () {
    echo "error: $@" 1>&2
}

[[ "$#" -gt 0 ]] || {err "$0: requires an argument" && exit 1}

export XDG_OPEN_DEPTH=$(( ${XDG_OPEN_DEPTH:-0} + 1 ))

if [[ $XDG_OPEN_DEPTH -gt 5 ]]; then
    err "recursive xdg-open loop" "$1"
    exit 1
fi

setopt REMATCH_PCRE
setopt EXTENDED_GLOB

if [ -e "$1" ]; then
    mime="$(file --mime-type --brief $1)"
    exists=1
fi

found=1

echo "xdg-open $1 $mime" >> ~/temp/open-log

while read -r mode query; do
    if [ $found != 0 ]; then
        case $mode in
            test)
                t="$1"
                1=${(q)1}
                eval $(eval echo $query)
                found=$?
                1=$t
                ;;
            name)
                [[ -n $exists && "$1" =~ "${query}" ]]
                found=$?
            ;;
            mime)
                [[ -n $exists && "$mime" =~ "${query}"  ]]
                found=$?
            ;;
            scheme)
                query="^${query}:"
                [[ -z $exists && "$1" =~ "${query}" ]]
                found=$?
            ;;
            url)
                [[ -z $exists && "$1" =~ "${query}" ]]
                found=$?
            ;;
        esac
    elif [ $mode = run ]; then
        eval $query
        exit 0
    elif [ $mode = exec ]; then
        eval exec $query
    fi
done < "$RULES_FILE"

TGT="$1"
autoload -U regexp-replace
regexp-replace TGT /+ /

CMD=$(yad --center --entry --on-top --completion --entry-label "Open $TGT with:" ${(ko)commands})

if [[ $? -eq 0 ]]; then
    echo "exec $CMD $TGT" >> ~/temp/open-log
    exec "$CMD" "$TGT"
else
    err "xdg-open failed: $1 has no matching rule"
    exit 1
fi
