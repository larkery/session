#!/usr/bin/env boot

(require '[clojure.java.io :as io]
         '[clojure.set :as set])

(defn sub [x y]
  (let [x (.toLowerCase x)]
    #(when (.contains (.toLowerCase %) x) [y])))

(def window-rules
  [
   (sub "nhm" :nhm)
   (sub "ccc" :ccc)
   (sub "firefox" :web)
   (sub "thermos" :thermos)
   (sub "roger" :roger)
   (sub "notmuch" :email)
   (sub "nhm helpdesk" :support)
   (sub "national household model" :in-nhm)
   (sub "osticket" :support)
   (sub "sap-steps" :sap-steps)
   #(when (= % "mail") #{:mail})
   (sub "heat-profiles" :heat-profiles)
   (sub "ting" :ting)

   (fn project-code [x]
     (let [c
           (-> (re-seq #"p/(\d{3})" x)
               first
               rest
               first)
           ]
       (when c [(keyword c)])))

   (fn ticket-code [x]
     (let [c
           (-> (re-seq #"Ticket #(\d+)" x)
               first
               rest
               first)
           ]
       (when c [(keyword (str "ticket-" c))]))
     )
   ]
  )

(defn apply-window-rules [message]
  (->> (mapcat #(% message) window-rules)
       (filter identity)
       set))

(defn update-state [state {event :event message :message}]
  (case event
    "window" (assoc state :windows (apply-window-rules message))
    "tag" (assoc state :tag message)
    state))

(let [df (java.text.SimpleDateFormat. "MMM dd EEE")

      split-line (comp rest first #(re-seq #"^(\d+) ([^ ]+) ?(.+)$" %))
      ]
    (defn quantize [time]
      (let [d (java.util.Date. ^Long (* 1000 time))]
        (.format df d)))

    (defn parse-line [line]
      (let [[time type msg] (split-line line)
            time-seconds (Integer/parseInt time)]
        {:hour (quantize time-seconds)
         :time time-seconds
         :event type
         :message msg})))

(defn reduce-state [events]
  (->> events

       (reduce (fn [{state :current-state
                 start-time :start-time
                 totals :totals :as accumulator}
                {event-time :time :as event}]
             (let [state' (update-state state event)]
               (if (= state' state)
                 accumulator
                 {:current-state state'
                  :start-time event-time
                  :totals
                  (if state
                    (update totals state
                            #(+ (or % 0) (- event-time (or start-time event-time))))
                    totals)})))
               {})

       :totals

       (map (fn [[state time]] [state (double (/ time 3600))]))

       (into {})
       ))

(defn process-db []
  (with-open [r (io/reader (str (System/getProperty "user.home")
                                "/.local/tracker.db"))]
    (let [lines (map parse-line (line-seq r))
          hours (group-by :hour lines)]
      (into {} (for [[hour events] hours] [hour (reduce-state events)])))))

(defn -main [& args]
  (let [groups (process-db)]
    (doseq [[group vals] groups]
      (printf "%s\n" group)
      (let [by-tag (group-by (comp :tag first) vals)]
        (doseq [[tag vals] by-tag]
          (let [tag-total-time (apply + (map second vals))
                vals (filter #(>= (second %) 0.1) vals)
                ]
            (when (>= tag-total-time 0.1)
              (if (= 1 (count vals))
                (printf "* %s %s %.1f\n"
                        tag
                        (:windows (first (first vals)))
                        tag-total-time)

                (do (printf "* %s %.1f\n" tag tag-total-time)
                    (doseq [[{wins :windows} time] (reverse (sort-by second vals))]
                      (printf "  - %s %.1f\n" wins time)
                      ))
                )
              ))))
      (println)
      )))
