#!/usr/bin/env boot

(require '[clojure.java.io :as io]
         '[clojure.set :as set])

(defn sub [x y]
  (let [x (.toLowerCase x)]
    #(when (.contains (.toLowerCase %) x) [y])))

(def window-rules
  [
   (sub "nhm" :nhm)
   (sub "ccc" :ccc)
   (sub "firefox" :web)
   (sub "thermos" :thermos)
   (sub "roger" :roger)
   (sub "notmuch" :email)
   (sub "nhm helpdesk" :support)
   (sub "national household model" :in-nhm)
   (sub "osticket" :support)
   (sub "sap-steps" :sap-steps)
   #(when (= % "mail") #{:mail})
   (sub "heat-profiles" :heat-profiles)
   (sub "ho ting guo" :ting)

   (fn project-code [x]
     (let [c
           (-> (re-seq #"p/(\d{3})" x)
               first
               rest
               first)
           ]
       (when c [(keyword c)])))

   (fn ticket-code [x]
     (let [c
           (-> (re-seq #"Ticket #(\d+)" x)
               first
               rest
               first)
           ]
       (when c [(keyword (str "ticket-" c))]))
     )
   ]
  )

(defn apply-window-rules [message]
  (->> (mapcat #(% message) window-rules)
       (filter identity)
       set))

(defn update-state [state {event :event message :message}]
  (case event
    "window" (assoc state :windows (apply-window-rules message))
    "tag" (assoc state :tag message)
    state))

(let [df (java.text.SimpleDateFormat. "MMM dd EEE")
      df2 (java.text.SimpleDateFormat. "YYYYMMdd")
      split-line (comp rest first #(re-seq #"^(\d+) ([^ ]+) ?(.+)$" %))
      ]
    (defn quantize [time]
      (let [d (java.util.Date. ^Long (* 1000 time))]
        [(Integer/parseInt (.format df2 d))
         (.format df d)]))

    (defn parse-line [line]
      (let [[time type msg] (split-line line)
            time-seconds (Integer/parseInt time)]
        {:hour (quantize time-seconds)
         :time time-seconds
         :event type
         :message msg})))

(defn reduce-state [events]
  (->> events

       (reduce (fn [{state :current-state
                 start-time :start-time
                 totals :totals :as accumulator}
                {event-time :time :as event}]
             (let [state' (update-state state event)]
               (if (= state' state)
                 accumulator
                 {:current-state state'
                  :start-time event-time
                  :totals
                  (if state
                    (update totals state
                            #(+ (or % 0) (- event-time (or start-time event-time))))
                    totals)})))
               {})

       :totals
       ))

(defn process-db []
  (with-open [r (io/reader (str (System/getProperty "user.home")
                                "/.local/tracker.db"))]
    (let [lines (map parse-line (line-seq r))
          hours (group-by :hour lines)]
      (into {} (for [[hour events] hours] [hour (reduce-state events)])))))

(defn format-ms [msec]
  (cond
    (> msec 1800)
    (format "%.1fh" (/ (double msec) 3600))

    (> msec 60)
    (format "%dm" (int (/ (double msec) 60)))

    :default
    (format "%ds" (int msec))
    )
  )

(defn -main [& args]
  (let [groups (process-db)]
    (doseq [group (sort-by first (keys groups))]
      (let [vals (groups group)]
        (printf "%s %s\n" (second group) (format-ms (apply + (map second vals))))
        (let [by-tag (group-by (comp :tag first) vals)]
          (doseq [[tag vals] by-tag]
            (let [tag-total-time (apply + (map second vals))
                  vals (filter #(and
                                 (not (empty? (:windows (first %))))
                                 (>= (second %) 10)) vals)
                  ]
              (if (= 1 (count vals))
                (printf "* %s %s %s\n"
                        tag
                        (:windows (first (first vals)))
                        (format-ms tag-total-time))

                (do (printf "* %s %s\n" tag (format-ms tag-total-time))
                    (doseq [[{wins :windows} time] (reverse (sort-by second vals))]
                      (printf "  - %s %s\n" wins (format-ms time))
                      ))
                )))))
      (println)
      )))
